#!/usr/bin/env python3
"""
Create Oracle app schema from schema.json and copy data from PostgreSQL.
Ensures Oracle has the same tables and data as schema.json (PostgreSQL source).
"""
import json
import os
import re
from pathlib import Path

from dotenv import load_dotenv
from sqlalchemy import create_engine, text

load_dotenv()
DATABASE_URL = os.environ.get("DATABASE_URL")
ORACLE_URL = os.environ.get("ORACLE_URL")
if not DATABASE_URL or not ORACLE_URL:
    raise SystemExit("DATABASE_URL and ORACLE_URL must be set in .env")

SCHEMA_JSON = Path(__file__).resolve().parent.parent / "schema.json"
with open(SCHEMA_JSON) as f:
    schema = json.load(f)

ORACLE_SCHEMA = "APP"

# PostgreSQL type -> Oracle type
PG_TO_ORACLE = {
    "bigint": "NUMBER(19)",
    "integer": "NUMBER(10)",
    "smallint": "NUMBER(5)",
    "text": "VARCHAR2(4000)",
    "boolean": "NUMBER(1)",
    "date": "DATE",
    "timestamp": "TIMESTAMP",
    "timestamp without time zone": "TIMESTAMP",
    "timestamp with time zone": "TIMESTAMP WITH TIME ZONE",
}


def pg_type_to_oracle(pg_type: str) -> str:
    pg_type = (pg_type or "").lower().strip()
    if pg_type.startswith("numeric(") or pg_type.startswith("decimal("):
        m = re.match(r"numeric\((\d+),(\d+)\)", pg_type) or re.match(r"decimal\((\d+),(\d+)\)", pg_type)
        if m:
            return f"NUMBER({m.group(1)},{m.group(2)})"
    return PG_TO_ORACLE.get(pg_type, "VARCHAR2(4000)")


def build_ddl(unique_constraints: list) -> list:
    """Build DDL statements for Oracle. Returns list of (stmt, params) or (stmt, None)."""
    tables = schema["tables"]
    order = ["stores", "suppliers", "customers", "products", "employees", "purchase_orders", "inventory", "purchase_order_items", "sales_orders", "sales_order_items"]
    ordered = {t["table"]: t for t in tables}
    tables_ordered = [ordered[n] for n in order if n in ordered]

    # Drop in reverse dependency order (dependents first)
    drop_stmts = []
    for t in reversed(tables_ordered):
        drop_stmts.append(
            f"BEGIN EXECUTE IMMEDIATE 'DROP TABLE \"{ORACLE_SCHEMA}\".\"{t['table']}\" CASCADE CONSTRAINTS'; "
            "EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )

    create_stmts = []
    for t in tables_ordered:
        name = t["table"]
        cols = []
        pk = t.get("primary_keys", [])
        for c in t["columns"]:
            ora_type = pg_type_to_oracle(c.get("type", "text"))
            is_identity = c["name"] in pk and c.get("is_incremental", False)
            if is_identity and "NUMBER" in ora_type:
                ora_type = f"{ora_type} GENERATED BY DEFAULT AS IDENTITY"
            null = "" if c.get("nullable", False) else " NOT NULL"
            cols.append(f'    "{c["name"]}" {ora_type}{null}')
        col_def = ",\n".join(cols)
        pk_constraint = f',\n    PRIMARY KEY ({", ".join(chr(34) + k + chr(34) for k in pk)})' if pk else ""
        create_stmts.append(f'CREATE TABLE "{ORACLE_SCHEMA}"."{name}" (\n{col_def}{pk_constraint}\n)')

    # Foreign keys
    fk_stmts = []
    for t in tables_ordered:
        for fk in t.get("foreign_keys", []):
            col = fk["column"]
            ref = fk["references"]
            ref_table, ref_col = ref.split(".")
            fk_name = f"fk_{t['table']}_{col}"[:30]
            fk_stmts.append(f'ALTER TABLE "{ORACLE_SCHEMA}"."{t["table"]}" ADD CONSTRAINT "{fk_name}" FOREIGN KEY ("{col}") REFERENCES "{ORACLE_SCHEMA}"."{ref_table}" ("{ref_col}")')

    # Unique constraints
    uq_stmts = []
    for cname, tname, col_list in unique_constraints:
        col_list_quoted = ", ".join(f'"{c.strip()}"' for c in col_list.split(","))
        safe_name = re.sub(r"[^a-zA-Z0-9_]", "_", cname)[:30]
        uq_stmts.append(f'ALTER TABLE "{ORACLE_SCHEMA}"."{tname}" ADD CONSTRAINT "uq_{tname}_{safe_name}" UNIQUE ({col_list_quoted})')

    return drop_stmts, create_stmts, fk_stmts, uq_stmts


def fetch_pg_unique_constraints(pg_engine) -> list:
    """Fetch UNIQUE constraints from PostgreSQL public schema."""
    with pg_engine.connect() as conn:
        rows = conn.execute(text("""
            SELECT tc.constraint_name, tc.table_name,
                   string_agg(kcu.column_name, ',' ORDER BY kcu.ordinal_position) AS columns
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
                ON tc.constraint_name = kcu.constraint_name AND tc.table_schema = kcu.table_schema
            WHERE tc.constraint_type = 'UNIQUE' AND tc.table_schema = 'public'
            GROUP BY tc.constraint_name, tc.table_name
            ORDER BY tc.table_name
        """)).fetchall()
        return [(r[0], r[1], r[2]) for r in rows]


def main():
    pg = create_engine(DATABASE_URL)
    oracle = create_engine(ORACLE_URL)

    unique_constraints = fetch_pg_unique_constraints(pg)
    drop_stmts, create_stmts, fk_stmts, uq_stmts = build_ddl(unique_constraints)

    with oracle.connect() as conn:
        for stmt in drop_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in create_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in fk_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in uq_stmts:
            try:
                conn.execute(text(stmt))
                conn.commit()
            except Exception as e:
                print(f"  Warning: {stmt[:60]}... -> {e}")

    # Copy data from PostgreSQL to Oracle
    tables = schema["tables"]
    order = ["stores", "suppliers", "customers", "products", "employees", "purchase_orders", "inventory", "purchase_order_items", "sales_orders", "sales_order_items"]
    ordered = {t["table"]: t for t in tables}
    tables_ordered = [ordered[n] for n in order if n in ordered]

    for t in tables_ordered:
        name = t["table"]
        cols = [c["name"] for c in t["columns"]]
        col_list = ", ".join(f'"{c}"' for c in cols)
        with pg.connect() as pg_conn:
            rows = pg_conn.execute(text(f'SELECT {col_list} FROM public."{name}"')).fetchall()
        if not rows:
            continue
        col_list_ora = ", ".join(f'"{c}"' for c in cols)
        placeholders = ", ".join([f":c{i}" for i in range(len(cols))])
        with oracle.connect() as ora_conn:
            for row in rows:
                params = {}
                for i, v in enumerate(row):
                    if isinstance(v, bool):
                        params[f"c{i}"] = 1 if v else 0
                    else:
                        params[f"c{i}"] = v
                ora_conn.execute(
                    text(f'INSERT INTO "{ORACLE_SCHEMA}"."{name}" ({col_list_ora}) VALUES ({placeholders})'),
                    params,
                )
            ora_conn.commit()
        print(f"  {name}: {len(rows)} rows")

    print("Done. Tables in app schema:")
    with oracle.connect() as conn:
        for row in conn.execute(text("""
            SELECT table_name FROM all_tables
            WHERE owner = :owner ORDER BY table_name
        """), {"owner": ORACLE_SCHEMA}):
            cnt = conn.execute(text(f'SELECT COUNT(*) FROM "{ORACLE_SCHEMA}"."{row[0]}"')).scalar()
            print(f"  {row[0]}: {cnt} rows")


if __name__ == "__main__":
    main()
