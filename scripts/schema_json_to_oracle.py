#!/usr/bin/env python3
"""
Create Oracle app schema from schema.json and copy data from PostgreSQL.
Ensures Oracle has the same tables and data as schema.json (PostgreSQL source).
"""
import json
import os
import re
import sys
from pathlib import Path

from sqlalchemy import create_engine, text

_scripts = Path(__file__).resolve().parent
if str(_scripts) not in sys.path:
    sys.path.insert(0, str(_scripts))
from keyvault_loader import load_env

load_env()
DATABASE_URL = os.environ.get("DATABASE_URL")
ORACLE_URL = os.environ.get("ORACLE_URL")
if not DATABASE_URL or not ORACLE_URL:
    raise SystemExit("DATABASE_URL and ORACLE_URL must be set (in .env or Key Vault)")

REPO_ROOT = Path(__file__).resolve().parent.parent
SCHEMA_CANDIDATES = [
    REPO_ROOT / "LATEST_SCHEMA" / "schema_public_postgresql.json",
    REPO_ROOT / "schema.json",
]
SCHEMA_JSON = next((p for p in SCHEMA_CANDIDATES if p.exists()), SCHEMA_CANDIDATES[-1])
with open(SCHEMA_JSON) as f:
    schema = json.load(f)

ORACLE_SCHEMA = "APP"

# PostgreSQL type -> Oracle type
PG_TO_ORACLE = {
    "bigint": "NUMBER(19)",
    "integer": "NUMBER(10)",
    "smallint": "NUMBER(5)",
    "text": "VARCHAR2(4000)",
    "boolean": "NUMBER(1)",
    "date": "DATE",
    "timestamp": "TIMESTAMP",
    "timestamp without time zone": "TIMESTAMP",
    "timestamp with time zone": "TIMESTAMP WITH TIME ZONE",
}


def pg_type_to_oracle(pg_type: str) -> str:
    pg_type = (pg_type or "").lower().strip()
    if pg_type.startswith("numeric(") or pg_type.startswith("decimal("):
        m = re.match(r"numeric\((\d+),(\d+)\)", pg_type) or re.match(r"decimal\((\d+),(\d+)\)", pg_type)
        if m:
            return f"NUMBER({m.group(1)},{m.group(2)})"
    return PG_TO_ORACLE.get(pg_type, "VARCHAR2(4000)")


def build_ddl(unique_constraints: list) -> list:
    """Build DDL statements for Oracle. Returns list of (stmt, params) or (stmt, None)."""
    tables = schema["tables"]
    order = ["stores", "suppliers", "customers", "products", "employees", "purchase_orders", "inventory", "purchase_order_items", "sales_orders", "sales_order_items"]
    ordered = {t["table"]: t for t in tables}
    tables_ordered = [ordered[n] for n in order if n in ordered]

    # Drop in reverse dependency order (dependents first)
    drop_stmts = []
    for t in reversed(tables_ordered):
        drop_stmts.append(
            f"BEGIN EXECUTE IMMEDIATE 'DROP TABLE \"{ORACLE_SCHEMA}\".\"{t['table']}\" CASCADE CONSTRAINTS'; "
            "EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        )

    create_stmts = []
    for t in tables_ordered:
        name = t["table"]
        cols = []
        pk = t.get("primary_keys", [])
        for c in t["columns"]:
            ora_type = pg_type_to_oracle(c.get("type", "text"))
            is_identity = c["name"] in pk and c.get("is_incremental", False)
            if is_identity and "NUMBER" in ora_type:
                ora_type = f"{ora_type} GENERATED BY DEFAULT AS IDENTITY"
            null = "" if c.get("nullable", False) else " NOT NULL"
            cols.append(f'    "{c["name"]}" {ora_type}{null}')
        col_def = ",\n".join(cols)
        pk_constraint = f',\n    PRIMARY KEY ({", ".join(chr(34) + k + chr(34) for k in pk)})' if pk else ""
        create_stmts.append(f'CREATE TABLE "{ORACLE_SCHEMA}"."{name}" (\n{col_def}{pk_constraint}\n)')

    # Foreign keys
    fk_stmts = []
    for t in tables_ordered:
        for fk in t.get("foreign_keys", []):
            col = fk["column"]
            ref = fk["references"]
            ref_table, ref_col = ref.split(".")
            fk_name = f"fk_{t['table']}_{col}"[:30]
            fk_stmts.append(f'ALTER TABLE "{ORACLE_SCHEMA}"."{t["table"]}" ADD CONSTRAINT "{fk_name}" FOREIGN KEY ("{col}") REFERENCES "{ORACLE_SCHEMA}"."{ref_table}" ("{ref_col}")')

    # Unique constraints
    uq_stmts = []
    for cname, tname, col_list in unique_constraints:
        col_list_quoted = ", ".join(f'"{c.strip()}"' for c in col_list.split(","))
        safe_name = re.sub(r"[^a-zA-Z0-9_]", "_", cname)[:30]
        uq_stmts.append(f'ALTER TABLE "{ORACLE_SCHEMA}"."{tname}" ADD CONSTRAINT "uq_{tname}_{safe_name}" UNIQUE ({col_list_quoted})')

    return drop_stmts, create_stmts, fk_stmts, uq_stmts


def fetch_pg_unique_constraints(pg_engine) -> list:
    """Fetch UNIQUE constraints from PostgreSQL public schema."""
    with pg_engine.connect() as conn:
        rows = conn.execute(text("""
            SELECT tc.constraint_name, tc.table_name,
                   string_agg(kcu.column_name, ',' ORDER BY kcu.ordinal_position) AS columns
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
                ON tc.constraint_name = kcu.constraint_name AND tc.table_schema = kcu.table_schema
            WHERE tc.constraint_type = 'UNIQUE' AND tc.table_schema = 'public'
            GROUP BY tc.constraint_name, tc.table_name
            ORDER BY tc.table_name
        """)).fetchall()
        return [(r[0], r[1], r[2]) for r in rows]


def _table_exists_oracle(conn, owner: str, table_name: str) -> bool:
    row = conn.execute(
        text(
            """
            SELECT 1
            FROM all_tables
            WHERE owner = :owner AND table_name = :table_name
            """
        ),
        {"owner": owner, "table_name": table_name},
    ).fetchone()
    return bool(row)


def _column_exists_oracle(conn, owner: str, table_name: str, column_name: str) -> bool:
    row = conn.execute(
        text(
            """
            SELECT 1
            FROM all_tab_columns
            WHERE owner = :owner AND table_name = :table_name AND column_name = :column_name
            """
        ),
        {"owner": owner, "table_name": table_name, "column_name": column_name},
    ).fetchone()
    return bool(row)


def _fk_exists_oracle(conn, owner: str, constraint_name: str) -> bool:
    row = conn.execute(
        text(
            """
            SELECT 1
            FROM all_constraints
            WHERE owner = :owner
              AND constraint_type = 'R'
              AND UPPER(constraint_name) = UPPER(:constraint_name)
            """
        ),
        {"owner": owner, "constraint_name": constraint_name},
    ).fetchone()
    return bool(row)


def _ensure_column_oracle(conn, owner: str, table_name: str, column_name: str, column_type: str) -> None:
    if not _table_exists_oracle(conn, owner, table_name):
        return
    if _column_exists_oracle(conn, owner, table_name, column_name):
        return
    conn.execute(
        text(
            f'ALTER TABLE "{owner}"."{table_name}" ADD ("{column_name}" {column_type})'
        )
    )


def _ensure_fk_oracle(
    conn,
    owner: str,
    table_name: str,
    constraint_name: str,
    column_name: str,
    ref_table: str,
    ref_column: str,
) -> None:
    if not _table_exists_oracle(conn, owner, table_name) or not _table_exists_oracle(conn, owner, ref_table):
        return
    if not _column_exists_oracle(conn, owner, table_name, column_name) or not _column_exists_oracle(conn, owner, ref_table, ref_column):
        return
    if _fk_exists_oracle(conn, owner, constraint_name):
        return
    conn.execute(
        text(
            f"""
            ALTER TABLE "{owner}"."{table_name}"
            ADD CONSTRAINT {constraint_name}
            FOREIGN KEY ("{column_name}") REFERENCES "{owner}"."{ref_table}" ("{ref_column}")
            """
        )
    )


def _oracle_literal(value: str) -> str:
    return "'" + value.replace("'", "''") + "'"


def enrich_for_analyzer_testing_oracle(oracle_engine, owner: str = ORACLE_SCHEMA) -> None:
    with oracle_engine.connect() as conn:
        _ensure_column_oracle(conn, owner, "products", "weight_value", "NUMBER(10,2)")
        _ensure_column_oracle(conn, owner, "products", "weight_unit", "VARCHAR2(16)")
        _ensure_column_oracle(conn, owner, "products", "length_value", "NUMBER(10,2)")
        _ensure_column_oracle(conn, owner, "products", "length_unit", "VARCHAR2(16)")
        _ensure_column_oracle(conn, owner, "products", "product_description", "CLOB")

        _ensure_column_oracle(conn, owner, "purchase_order_items", "ordered_qty_value", "NUMBER(10,2)")
        _ensure_column_oracle(conn, owner, "purchase_order_items", "ordered_qty_unit", "VARCHAR2(16)")

        _ensure_column_oracle(conn, owner, "sales_order_items", "sold_qty_value", "NUMBER(10,2)")
        _ensure_column_oracle(conn, owner, "sales_order_items", "sold_qty_unit", "VARCHAR2(16)")

        _ensure_column_oracle(conn, owner, "inventory", "stock_value", "NUMBER(10,2)")
        _ensure_column_oracle(conn, owner, "inventory", "stock_unit", "VARCHAR2(16)")

        _ensure_column_oracle(conn, owner, "purchase_orders", "approver_employee_id", "NUMBER(19)")
        _ensure_column_oracle(conn, owner, "sales_orders", "sales_rep_employee_id", "NUMBER(19)")
        _ensure_column_oracle(conn, owner, "products", "primary_supplier_id", "NUMBER(19)")

        if _table_exists_oracle(conn, owner, "products"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."products"
                    SET "weight_value" = ROUND(0.50 + (MOD("product_id", 20) * 0.25), 2),
                        "weight_unit" = CASE WHEN MOD("product_id", 2) = 0 THEN 'kg' ELSE 'lb' END,
                        "length_value" = ROUND(10 + (MOD("product_id", 30) * 1.5), 2),
                        "length_unit" = CASE WHEN MOD("product_id", 2) = 0 THEN 'cm' ELSE 'in' END,
                        "product_description" = 'Product ' || NVL("name", 'unknown') || ' in ' || NVL("category", 'general') || ' category.',
                        "primary_supplier_id" = NVL("primary_supplier_id", "supplier_id")
                    """
                )
            )
            if _table_exists_oracle(conn, owner, "suppliers"):
                conn.execute(
                    text(
                        f"""
                        UPDATE "{owner}"."products"
                        SET "primary_supplier_id" = (
                            SELECT MIN(s."supplier_id")
                            FROM "{owner}"."suppliers" s
                        )
                        WHERE "primary_supplier_id" IS NULL
                        """
                    )
                )

        if _table_exists_oracle(conn, owner, "purchase_order_items"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."purchase_order_items"
                    SET "ordered_qty_value" = NVL("quantity", 0),
                        "ordered_qty_unit" = CASE WHEN MOD("po_item_id", 3) = 0 THEN 'box' ELSE 'ea' END
                    """
                )
            )

        if _table_exists_oracle(conn, owner, "sales_order_items"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."sales_order_items"
                    SET "sold_qty_value" = NVL("quantity", 0),
                        "sold_qty_unit" = CASE WHEN MOD("sales_order_item_id", 3) = 0 THEN 'box' ELSE 'ea' END
                    """
                )
            )

        if _table_exists_oracle(conn, owner, "inventory"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."inventory"
                    SET "stock_value" = NVL("quantity_on_hand", 0),
                        "stock_unit" = 'ea'
                    """
                )
            )

        if _table_exists_oracle(conn, owner, "purchase_orders") and _table_exists_oracle(conn, owner, "employees"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."purchase_orders" po
                    SET "approver_employee_id" = (
                        SELECT MIN(e."employee_id")
                        FROM "{owner}"."employees" e
                        WHERE e."store_id" = po."store_id"
                    )
                    WHERE po."approver_employee_id" IS NULL
                    """
                )
            )
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."purchase_orders"
                    SET "approver_employee_id" = (
                        SELECT MIN(e."employee_id")
                        FROM "{owner}"."employees" e
                    )
                    WHERE "approver_employee_id" IS NULL
                    """
                )
            )

        if _table_exists_oracle(conn, owner, "sales_orders"):
            conn.execute(
                text(
                    f"""
                    UPDATE "{owner}"."sales_orders"
                    SET "sales_rep_employee_id" = NVL("sales_rep_employee_id", "employee_id")
                    """
                )
            )
            if _table_exists_oracle(conn, owner, "employees"):
                conn.execute(
                    text(
                        f"""
                        UPDATE "{owner}"."sales_orders" so
                        SET "sales_rep_employee_id" = (
                            SELECT MIN(e."employee_id")
                            FROM "{owner}"."employees" e
                            WHERE e."store_id" = so."store_id"
                        )
                        WHERE so."sales_rep_employee_id" IS NULL
                        """
                    )
                )

        _ensure_fk_oracle(
            conn,
            owner,
            "purchase_orders",
            "FK_PO_APPROVER_EMP",
            "approver_employee_id",
            "employees",
            "employee_id",
        )
        _ensure_fk_oracle(
            conn,
            owner,
            "sales_orders",
            "FK_SO_SALES_REP_EMP",
            "sales_rep_employee_id",
            "employees",
            "employee_id",
        )
        _ensure_fk_oracle(
            conn,
            owner,
            "products",
            "FK_PRODUCTS_PRIMARY_SUP",
            "primary_supplier_id",
            "suppliers",
            "supplier_id",
        )

        table_descriptions = {
            "products": "Master product catalog including physical units for analyzer unit-context testing.",
            "purchase_order_items": "Line items with order quantities and explicit unit labels.",
            "sales_order_items": "Sales line items with sold quantity and explicit unit labels.",
            "inventory": "Current stock levels with normalized stock unit representation.",
            "purchase_orders": "Procurement headers including approver employee relationship.",
            "sales_orders": "Sales headers including assigned sales representative relationship.",
        }
        column_descriptions = {
            ("products", "weight_value"): "Measured product weight value.",
            ("products", "weight_unit"): "Source weight unit (kg/lb) used for unit inference testing.",
            ("products", "length_value"): "Measured product length value.",
            ("products", "length_unit"): "Source length unit (cm/in) used for unit inference testing.",
            ("products", "product_description"): "Human-readable product description for text semantics.",
            ("products", "primary_supplier_id"): "Primary supplier relationship used for join candidate detection.",
            ("purchase_order_items", "ordered_qty_value"): "Ordered quantity as numeric value.",
            ("purchase_order_items", "ordered_qty_unit"): "Ordered quantity unit (ea/box).",
            ("sales_order_items", "sold_qty_value"): "Sold quantity as numeric value.",
            ("sales_order_items", "sold_qty_unit"): "Sold quantity unit (ea/box).",
            ("inventory", "stock_value"): "Current stock quantity as numeric value.",
            ("inventory", "stock_unit"): "Current stock unit label.",
            ("purchase_orders", "approver_employee_id"): "Approver employee foreign key for procurement workflow.",
            ("sales_orders", "sales_rep_employee_id"): "Sales representative foreign key for order ownership.",
        }
        for table_name, description in table_descriptions.items():
            if _table_exists_oracle(conn, owner, table_name):
                conn.execute(text(f'COMMENT ON TABLE "{owner}"."{table_name}" IS {_oracle_literal(description)}'))
        for (table_name, column_name), description in column_descriptions.items():
            if _column_exists_oracle(conn, owner, table_name, column_name):
                conn.execute(
                    text(f'COMMENT ON COLUMN "{owner}"."{table_name}"."{column_name}" IS {_oracle_literal(description)}'),
                )

        conn.commit()



def main():
    pg = create_engine(DATABASE_URL)
    oracle = create_engine(ORACLE_URL)

    unique_constraints = fetch_pg_unique_constraints(pg)
    drop_stmts, create_stmts, fk_stmts, uq_stmts = build_ddl(unique_constraints)

    with oracle.connect() as conn:
        for stmt in drop_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in create_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in fk_stmts:
            conn.execute(text(stmt))
            conn.commit()

        for stmt in uq_stmts:
            try:
                conn.execute(text(stmt))
                conn.commit()
            except Exception as e:
                print(f"  Warning: {stmt[:60]}... -> {e}")

    # Copy data from PostgreSQL to Oracle
    tables = schema["tables"]
    order = ["stores", "suppliers", "customers", "products", "employees", "purchase_orders", "inventory", "purchase_order_items", "sales_orders", "sales_order_items"]
    ordered = {t["table"]: t for t in tables}
    tables_ordered = [ordered[n] for n in order if n in ordered]

    for t in tables_ordered:
        name = t["table"]
        cols = [c["name"] for c in t["columns"]]
        col_list = ", ".join(f'"{c}"' for c in cols)
        with pg.connect() as pg_conn:
            rows = pg_conn.execute(text(f'SELECT {col_list} FROM public."{name}"')).fetchall()
        if not rows:
            continue
        col_list_ora = ", ".join(f'"{c}"' for c in cols)
        placeholders = ", ".join([f":c{i}" for i in range(len(cols))])
        with oracle.connect() as ora_conn:
            for row in rows:
                params = {}
                for i, v in enumerate(row):
                    if isinstance(v, bool):
                        params[f"c{i}"] = 1 if v else 0
                    else:
                        params[f"c{i}"] = v
                ora_conn.execute(
                    text(f'INSERT INTO "{ORACLE_SCHEMA}"."{name}" ({col_list_ora}) VALUES ({placeholders})'),
                    params,
                )
            ora_conn.commit()
        print(f"  {name}: {len(rows)} rows")

    enrich_for_analyzer_testing_oracle(oracle, ORACLE_SCHEMA)

    print("Done. Tables in app schema:")
    with oracle.connect() as conn:
        for row in conn.execute(text("""
            SELECT table_name FROM all_tables
            WHERE owner = :owner ORDER BY table_name
        """), {"owner": ORACLE_SCHEMA}):
            cnt = conn.execute(text(f'SELECT COUNT(*) FROM "{ORACLE_SCHEMA}"."{row[0]}"')).scalar()
            print(f"  {row[0]}: {cnt} rows")


if __name__ == "__main__":
    main()
